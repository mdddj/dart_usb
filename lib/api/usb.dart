// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:meta/meta.dart' as meta;
part 'usb.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `cmp`, `eq`, `eq`, `fmt`, `fmt`, `hash`, `hash`, `into`, `into`, `into`, `partial_cmp`

/// get all usb infos
List<UsbInfo> getUsbInfos() => RustLib.instance.api.crateApiUsbGetUsbInfos();

///监听USB事件,它在线程池中执行
Stream<List<UsbInfo>> listenUsbEventHandle({BigInt? sleep}) =>
    RustLib.instance.api.crateApiUsbListenUsbEventHandle(sleep: sleep);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UsbHandle>>
abstract class UsbHandle implements RustOpaqueInterface {
  ///声明接口 (通常是0)
  void claimInterface({required int iface});

  ///读取数据
  Stream<Uint8List> readInterrupt(
      {required int endpoint, required BigInt timeout});

  ///释放接口
  void releaseInterface({required int iface});

  ///设置设备配置(通常1)
  void setActiveConfiguration({required int config});

  ///写数据
  BigInt writeData(
      {required int endpoint, required List<int> buf, required BigInt timeout});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UsbInfo>>
abstract class UsbInfo implements RustOpaqueInterface {
  int get address;

  int get busNumber;

  int get classCode;

  int get descriptorType;

  UsbVersion get deviceVersion;

  int get length;

  int? get manufacturerStringIndex;

  int get maxPacketSize;

  int get numConfigurations;

  int get productId;

  int? get productStringIndex;

  int get protocolCode;

  int? get serialNumberStringIndex;

  UsbSpeed get speed;

  int get subClassCode;

  UsbVersion get usbVersion;

  int get vendorId;

  set address(int address);

  set busNumber(int busNumber);

  set classCode(int classCode);

  set descriptorType(int descriptorType);

  set deviceVersion(UsbVersion deviceVersion);

  set length(int length);

  set manufacturerStringIndex(int? manufacturerStringIndex);

  set maxPacketSize(int maxPacketSize);

  set numConfigurations(int numConfigurations);

  set productId(int productId);

  set productStringIndex(int? productStringIndex);

  set protocolCode(int protocolCode);

  set serialNumberStringIndex(int? serialNumberStringIndex);

  set speed(UsbSpeed speed);

  set subClassCode(int subClassCode);

  set usbVersion(UsbVersion usbVersion);

  set vendorId(int vendorId);

  UsbHandle open();

  UsbName readUsbName();
}

@freezed
@meta.immutable
sealed class UsbName with _$UsbName {
  const factory UsbName({
    String? manufacturerName,
    String? productName,
    String? serialNumber,
  }) = _UsbName;
}

/// USB device speeds. Indicates the speed at which a device is operating.
/// - [libusb_supported_speed](http://libusb.sourceforge.net/api-1.0/group__libusb__dev.html#ga1454797ecc0de4d084c1619c420014f6)
/// - [USB release versions](https://en.wikipedia.org/wiki/USB#Release_versions)
enum UsbSpeed {
  /// The operating system doesn't know the device speed.
  unknown,

  /// The device is operating at low speed (1.5 Mbps).
  low,

  /// The device is operating at full speed (12 Mbps).
  full,

  /// The device is operating at high speed (480 Mbps).
  high,

  /// The device is operating at super speed (5 Gbps).
  super_,

  /// The device is operating at super speed plus (10 Gbps).
  superPlus,
  ;
}

@freezed
@meta.immutable
sealed class UsbVersion with _$UsbVersion {
  const factory UsbVersion({
    required int field0,
    required int field1,
    required int field2,
  }) = _UsbVersion;
}
